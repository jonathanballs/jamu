#!/usr/bin/python3
# (C) Jonathan Balls
# Generates a JSON with the assembled hex and the original instruction
# Each instruction should be assembled individually (as if it were the first
# instruction then compared the hex which is generated by llvm (through capstone).

from keystone import *
import json

TOTAL_INS_TESTED = 0
NUM_INS_PER_TEST = 256
CONDITIONS = [
        'eq', 'ne', 'cs', 'cc',
        'mi', 'pl', 'vs', 'vc',
        'hi', 'ls', 'ge', 'lt',
        'gt', 'le', 'al', '']

output_json_obj = []

def test_code(test_name, source):

    test_json_obj = { "test_name": test_name, "test_cases": {} }

    # Initialise keystone disasm
    ks = Ks(KS_ARCH_ARM, KS_MODE_ARM)

    for line in source.split('\n'):
        if not line:
            continue

        global TOTAL_INS_TESTED
        TOTAL_INS_TESTED += 1;

        k_bytes = None
        try:
            k_bytes = bytes(ks.asm(str.encode(line), addr=0)[0]).hex()
        except KsError as e:
            print(" \033[91mâœ—\033[0m Keystone failed to compile '{}' ({})".format(
                line,
                e.message
                ))
            return
        test_json_obj["test_cases"][line] = k_bytes

    output_json_obj.append(test_json_obj)
        

#
#
# BRANCHING
# Tests the B, BL and BX instructions
#
source = ""
for i in range(NUM_INS_PER_TEST):
    source += "b {}\n".format(i<<2)
for i in range(NUM_INS_PER_TEST):
    source += "b{} {}\n".format(CONDITIONS[i% 16], i<<2);
test_code("Testing b instruction", source)

source = ""
for i in range(NUM_INS_PER_TEST):
    source += "bl {}\n".format(i<<2)
for i in range(NUM_INS_PER_TEST):
    source += "bl{} {}\n".format(CONDITIONS[i%16], i<<2)
test_code("Testing bl instruction", source)

source = ""
for i in range(NUM_INS_PER_TEST):
    source += "bx R{}\n".format(i%16)
for i in range(NUM_INS_PER_TEST):
    source += "bx{} R{}\n".format(CONDITIONS[i%16], str(i%16))
test_code("Testing bx instruction", source)

#
#
# DATA PROCESSING INSTRUCTIONS
#
#
MATHEMATICAL_INSN = ['and', 'eor', 'sub', 'rsb', 'add', 'adc', 'sbc', 'rsc', 'orr', 'bic']
for insn in MATHEMATICAL_INSN:
    source = ''
    for i in range(NUM_INS_PER_TEST):
        source += "{} R{}, R{}, R{}\n".format(insn, i%16, i//16, (i+8)%16)
    for i in range(NUM_INS_PER_TEST):
        source += "{} R{}, R{}, #{}\n".format(insn, i%16, i//16, i)
    for i in range(NUM_INS_PER_TEST): # Conditions
        source += "{}{} R{}, R{}, #{}\n".format(insn, CONDITIONS[i%16], i%16, i//16, i)
    for i in range(NUM_INS_PER_TEST):
        source += "{}S{} R{}, R{}, R{}\n".format(insn, CONDITIONS[i%16], i%16, i//16, i%16)
    for i in range(NUM_INS_PER_TEST): # Set bit
        source += "{}S R{}, R{}, #{}\n".format(insn, i%16, i//16, i)
    for i in range(NUM_INS_PER_TEST):
        source += "{}S R{}, R{}, R{}\n".format(insn, i%16, i//16, i%16)
    test_code("Testing {} instruction".format(insn), source)


COMP_INSN = ['tst', 'teq', 'cmp', 'cmn']
for insn in COMP_INSN:
    source = ''
    for i in range(NUM_INS_PER_TEST):
        source += "{} R{}, R{}\n".format(insn, i%16, i//16)
    for i in range(NUM_INS_PER_TEST):
        source += "{} R{}, #{}\n".format(insn, i%16, i)
    for i in range(NUM_INS_PER_TEST):
        source += "{}{} R{}, R{}\n".format(insn, CONDITIONS[i%16], i%16, i//16)
    for i in range(NUM_INS_PER_TEST):
        source += "{}{} R{}, #{}\n".format(insn, CONDITIONS[i%16], i%16, i)
    test_code("Testing {} instruction".format(insn), source)


MOV_INSN = ['mov', 'mvn']
for insn in MOV_INSN:
    source = ''
    for i in range(NUM_INS_PER_TEST):
        source += "{} R{}, R{}\n".format(insn, i%16, i//16)
    for i in range(NUM_INS_PER_TEST):
        source += "{} R{}, #{}\n".format(insn, i%16, i)
    for i in range(NUM_INS_PER_TEST):
        source += "{}{} R{}, R{}\n".format(insn, CONDITIONS[i%16], i%16, i//16)
    for i in range(NUM_INS_PER_TEST):
        source += "{}{} R{}, #{}\n".format(insn, CONDITIONS[i%16], i%16, i)
    for i in range(NUM_INS_PER_TEST):
        source += "{}s{} R{}, R{}\n".format(insn, CONDITIONS[i%16], i%16, i//16)
    for i in range(NUM_INS_PER_TEST):
        source += "{}s{} R{}, #{}\n".format(insn, CONDITIONS[i%16], i%16, i)
    test_code("Testing {} instruction".format(insn), source)


#
#
# SOFTWARE INTERRUPTS
#
#

source = ''
for i in range(NUM_INS_PER_TEST):
    source += "swi #{}\n".format(i)
for i in range(NUM_INS_PER_TEST):
    source += "swi{} #{}\n".format(CONDITIONS[i%16], i)
test_code("Testing swi instruction", source)


#
#
# SINGLE STORE INSTRUCTIONS
#
#
SSTORE_INSN = ['ldr', 'str']
for insn in SSTORE_INSN:
    source = ''

    #  label: ldr R0, label
    for i in range(NUM_INS_PER_TEST):
        source += "label: {} R{}, label\n".format(insn, i%16)

    #  ldr r0, [r0, r0]
    #  ldr r0, [r0, r0]!
    for i in range(NUM_INS_PER_TEST):
        source += "{} R{}, [R{}, R{}]\n".format(insn, i%16, (i+8)%16, int(i/16))
    for i in range(NUM_INS_PER_TEST):
        source += "{} R{}, [R{}, R{}]!\n".format(insn, i%16, (i+8)%16, int(i/16))

    #  ldr r0, [r0, #0]
    #  ldr r0, [r0, #0]!
    for i in range(NUM_INS_PER_TEST):
        source += "{} R{}, [R{}, #{}]\n".format(insn, i%16, (i+8)%16, int(i/16))
    for i in range(NUM_INS_PER_TEST):
        source += "{} R{}, [R{}, #{}]!\n".format(insn, i%16, (i+8)%16, i*4)

    source += 'label:;'
    test_code("Testing {} instruction".format(insn), source)

json_text = json.dumps(output_json_obj, indent = 4)
with open('test_suite.json', 'w+') as f:
    f.write(json_text)

print("Generated tests for {} instructions".format(TOTAL_INS_TESTED))

